import React, { useEffect, useMemo, useRef, useState } from "react";

// AMC Capability Proofs – Interactive MVP
// Single-file React prototype using TailwindCSS classes (no external UI libs)
// Features:
// - Proof Card creator with validation
// - Audit Tables (Evidence vs Band; Identity/Soul-Safety)
// - Translation Studio (stewardship/justice/thrift/beauty)
// - Adversarial Audit mode
// - ABM Sandbox: Schelling segregation simulation to illustrate edge complexity & failure envelopes
// - Example proofs loader
// - Local storage persistence

// ---------- Types ----------

type OutcomeBand = {
  point: number; // e.g., -27 (percentage change)
  low: number;   // e.g., -19
  high: number;  // e.g., -35
  unit: string;  // "% no-shows" or "kWh" etc.
};

type ProofLevel = 0 | 1 | 2 | 3 | 4;

type CapabilityProof = {
  id: string;
  title: string;
  functionDesc: string;
  context: string;
  timeframe: string;
  outcomeBand: OutcomeBand;
  baselineDesc: string;
  protocol: string[]; // 5–9 steps
  evidenceDesign: string; // stepped-wedge, matched cohort, synthetic control, etc.
  nParticipants?: number;
  durationWeeks?: number;
  robustnessChecks: string[]; // sensitivity, replication, ablations
  fairnessPanel: string; // notes on hidden harms check
  identitySafeguards: string[]; // opt-in clarity, exit, role choice, etc.
  atcfNotes: string; // identity coherence considerations
  governance: string; // steward, metrics cadence, stop rules
  failureEnvelope: string; // where it fails
  proofLevel: ProofLevel;
  steward: string;
  updatedAt: string; // ISO
  translations: {
    stewardship?: string;
    justice?: string;
    thrift?: string;
    beauty?: string;
  };
  adversarialFindings?: string;
};

// ---------- Utilities ----------

function uid() {
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function fmtPct(n: number) {
  const sign = n > 0 ? "+" : "";
  return `${sign}${n.toFixed(1)}%`;
}

// Simple quality scoring (informational only)
function scoreProof(p: CapabilityProof) {
  let score = 0;
  // completeness
  const filledCore = [p.title, p.functionDesc, p.context, p.outcomeBand, p.protocol[0], p.evidenceDesign, p.governance, p.failureEnvelope].every(Boolean);
  score += filledCore ? 25 : 10;
  // level weight
  score += (p.proofLevel * 12);
  // robustness checks
  score += clamp(p.robustnessChecks.length * 4, 0, 20);
  // identity safeguards
  score += clamp(p.identitySafeguards.length * 4, 0, 20);
  // translations
  const tCount = [p.translations.stewardship, p.translations.justice, p.translations.thrift, p.translations.beauty].filter(Boolean).length;
  score += clamp(tCount * 3, 0, 12);
  return clamp(score, 0, 100);
}

function nowISO() { return new Date().toISOString(); }

// ---------- Example Proofs ----------

function exampleProofs(): CapabilityProof[] {
  const ex1: CapabilityProof = {
    id: uid(),
    title: "Clinic No-Show Reduction (Urban A/B)",
    functionDesc: "Reduce missed specialist appointments",
    context: "Urban clinics A/B; adults 18–64",
    timeframe: "16 weeks",
    outcomeBand: { point: -27, low: -19, high: -35, unit: "% no-shows" },
    baselineDesc: "Baseline averaged 28% no-show over prior 12 weeks",
    protocol: [
      "Pre-visit SMS reminders with respectful language",
      "Peer navigator outreach for barrier triage",
      "Transit voucher offered; no pressure to accept",
      "Opt-out respected at each contact",
      "Follow-up nudge 24h post-visit for rescheduling"
    ],
    evidenceDesign: "Stepped-wedge rollout with matched control weeks; pre-registered",
    nParticipants: 840,
    durationWeeks: 16,
    robustnessChecks: [
      "Second-site replication achieved −24%",
      "Sensitivity to weekends and weather",
      "Ablation: removing transit voucher collapses effect"
    ],
    fairnessPanel: "No differential harm detected; translated materials added",
    identitySafeguards: [
      "Clear opt-in/opt-out",
      "Navigator language/gender choice when requested",
      "Audit for coercion; none reported"
    ],
    atcfNotes: "Exit-rate symmetry within 1.1×; no identity-pressure complaints",
    governance: "Weekly metrics review; stop rule if complaints >2% or exit asymmetry >1.5×",
    failureEnvelope: "Rural sites without transit partners; effect collapses",
    proofLevel: 2,
    steward: "Dr. R. Alvarez",
    updatedAt: nowISO(),
    translations: {
      stewardship: "We honor patients' time: fewer wasted trips, more kept promises.",
      justice: "Barriers fall hardest on the vulnerable; we remove them without pressure.",
      thrift: "Every kept appointment saves downstream costs for all of us.",
      beauty: "Care that arrives on time feels like dignity made visible."
    },
    adversarialFindings: "Watch holiday weeks; effect narrows."
  };

  const ex2: CapabilityProof = {
    id: uid(),
    title: "Neighborhood Peak Shaving (6 Blocks)",
    functionDesc: "Reduce peak-hour electricity demand",
    context: "Mixed-income neighborhood; summer evenings 6–9pm",
    timeframe: "12 weeks",
    outcomeBand: { point: -40, low: -35, high: -45, unit: "% peak kW" },
    baselineDesc: "Smart meter baseline from prior summer",
    protocol: [
      "Appliance timer kits with opt-in setup",
      "Micro-grid coordination for shared storage",
      "Voluntary 'quiet hour' social norm",
      "Weekly feedback cards to households"
    ],
    evidenceDesign: "Season-over-season with independent meter audit; synthetic control blocks",
    nParticipants: 210,
    durationWeeks: 12,
    robustnessChecks: [
      "Two-season stability within band",
      "Independent audit verifies readings"
    ],
    fairnessPanel: "No rebound burden; incentives scaled by income",
    identitySafeguards: ["No required schedule change", "Opt-out any time"],
    atcfNotes: "Participants define dignity lines; no reports of social shaming",
    governance: "Energy guild oversight; stop if complaints >1.5%",
    failureEnvelope: "Landlord–tenant split incentive weakens participation",
    proofLevel: 2,
    steward: "Energy Guild #4",
    updatedAt: nowISO(),
    translations: {
      stewardship: "We care for the grid like a commons.",
      justice: "Lower bills and fewer outages for those who bear the worst.",
      thrift: "Cheaper than building new peaker plants.",
      beauty: "Evening streets hum softer, and sleep comes easier."
    }
  };

  const ex3: CapabilityProof = {
    id: uid(),
    title: "Schelling-Aware Housing Mix",
    functionDesc: "Reduce emergent clustering without restricting choice",
    context: "City districts with diverse demographics",
    timeframe: "3 quarters",
    outcomeBand: { point: -32, low: -25, high: -40, unit: "% clustering index" },
    baselineDesc: "Pre-policy clustering index",
    protocol: [
      "Expand default search radius in housing portal",
      "Seed mixed-amenity hubs",
      "Incentivize 'bridge groups' to ease cross-tract moves",
      "Quarterly edge metrics with public dashboards"
    ],
    evidenceDesign: "ABM sandbox preview + staged rollout across districts",
    nParticipants: 1200,
    durationWeeks: 36,
    robustnessChecks: [
      "Cross-district replication",
      "Sensitivity to transit access"
    ],
    fairnessPanel: "No penalties for choices; only added options/incentives",
    identitySafeguards: ["Freedom of choice preserved", "No pressure to relocate"],
    atcfNotes: "Identity-respecting incentives only",
    governance: "Civic lab monitors edge metrics; stop if dissatisfaction >2%",
    failureEnvelope: "Poor transit undermines effect; pivot to mobility first",
    proofLevel: 1,
    steward: "City Civic Lab",
    updatedAt: nowISO(),
    translations: {
      stewardship: "We tend our neighborhoods like gardens, avoiding monocultures.",
      justice: "Open more doors, not fewer; remove friction, not freedom.",
      thrift: "Smarter search beats costly mandates.",
      beauty: "Variety makes a city sing."
    }
  };

  return [ex1, ex2, ex3];
}

// ---------- Local Storage ----------

const LS_KEY = "amc_proofs_v1";

function loadProofsLS(): CapabilityProof[] {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw) as CapabilityProof[];
    return parsed;
  } catch {
    return [];
  }
}

function saveProofsLS(proofs: CapabilityProof[]) {
  try { localStorage.setItem(LS_KEY, JSON.stringify(proofs)); } catch {}
}

// ---------- ABM: Schelling Sandbox ----------

type Cell = "A" | "B" | "";

function randomChoice<T>(arr: T[]): T { return arr[Math.floor(Math.random()*arr.length)]; }

function generateGrid(size: number, shareA: number, vacancy: number): Cell[] {
  const total = size*size;
  const numEmpty = Math.round(total*vacancy);
  const numAgents = total - numEmpty;
  const numA = Math.round(numAgents*shareA);
  const numB = numAgents - numA;
  const cells: Cell[] = Array(total).fill("");
  let pool: Cell[] = [ ...Array(numA).fill("A"), ...Array(numB).fill("B"), ...Array(numEmpty).fill("") ];
  for (let i=0;i<total;i++) {
    const idx = Math.floor(Math.random()*pool.length);
    cells[i] = pool[idx];
    pool.splice(idx,1);
  }
  return cells;
}

function neighbors(idx: number, size: number): number[] {
  const x = idx % size, y = Math.floor(idx/size);
  const res: number[] = [];
  for (let dy=-1; dy<=1; dy++) {
    for (let dx=-1; dx<=1; dx++) {
      if (dx===0 && dy===0) continue;
      const nx = x+dx, ny = y+dy;
      if (nx>=0 && nx<size && ny>=0 && ny<size) res.push(ny*size+nx);
    }
  }
  return res;
}

function stepSchelling(cells: Cell[], size: number, simThresh: number): { cells: Cell[]; moved: number; satisfiedPct: number; avgSame: number; } {
  const empties: number[] = [];
  const unsatisfied: number[] = [];
  let satisfiedCount = 0;
  let totalSameFrac = 0;
  for (let i=0;i<cells.length;i++) {
    const c = cells[i];
    if (c === "") { empties.push(i); continue; }
    const ns = neighbors(i,size);
    let like = 0, tot = 0;
    for (const j of ns) {
      if (cells[j]!=="") { tot++; if (cells[j]===c) like++; }
    }
    const frac = tot===0 ? 1 : like/tot; // isolated agents are satisfied
    totalSameFrac += frac;
    if (frac >= simThresh) { satisfiedCount++; } else { unsatisfied.push(i); }
  }
  const newCells = cells.slice();
  let moved = 0;
  // shuffle unsatisfied for randomness
  for (let k = unsatisfied.length - 1; k>0; k--) { const r = Math.floor(Math.random()*(k+1)); [unsatisfied[k], unsatisfied[r]] = [unsatisfied[r], unsatisfied[k]]; }
  for (const i of unsatisfied) {
    if (empties.length === 0) break;
    const c = newCells[i];
    if (c === "") continue;
    const eIdx = Math.floor(Math.random()*empties.length);
    const to = empties[eIdx];
    empties.splice(eIdx,1);
    newCells[to] = c;
    newCells[i] = "";
    empties.push(i);
    moved++;
  }
  const satisfiedPct = (satisfiedCount / (cells.length - empties.length)) * 100;
  const avgSame = totalSameFrac / (cells.length - empties.length);
  return { cells: newCells, moved, satisfiedPct, avgSame };
}

function SegregationIndex({cells, size}:{cells:Cell[]; size:number}){
  // simple index: fraction of neighboring pairs that are same-type
  const pairs: number[] = [];
  let same = 0, tot = 0;
  for (let i=0;i<cells.length;i++){
    const c = cells[i]; if (c === "") continue;
    for(const j of neighbors(i,size)){
      if (j>i && cells[j]!=="") { tot++; if (cells[j]===c) same++; }
    }
  }
  const frac = tot===0 ? 0 : same/tot;
  return (
    <div className="text-sm text-gray-700 mt-1">Segregation index (neighbor similarity): {(frac*100).toFixed(1)}%</div>
  );
}

function ABMSandbox(){
  const [size,setSize] = useState(20);
  const [shareA,setShareA] = useState(0.5);
  const [vacancy,setVacancy] = useState(0.2);
  const [threshold,setThreshold] = useState(0.3);
  const [cells,setCells] = useState<Cell[]>(()=>generateGrid(20,0.5,0.2));
  const [iter,setIter] = useState(0);
  const [running,setRunning] = useState(false);
  const [stats,setStats] = useState<{moved:number;sat:number;avgSame:number}>({moved:0,sat:0,avgSame:0});
  const timerRef = useRef<number | null>(null);

  function reset(){
    setCells(generateGrid(size,shareA,vacancy));
    setIter(0); setStats({moved:0,sat:0,avgSame:0}); setRunning(false);
  }

  function step(){
    const {cells: c2, moved, satisfiedPct, avgSame} = stepSchelling(cells,size,threshold);
    setCells(c2); setIter(it=>it+1); setStats({moved, sat:satisfiedPct, avgSame});
  }

  useEffect(()=>{ reset(); /* eslint-disable-next-line */ },[size,shareA,vacancy]);

  useEffect(()=>{
    if (running) {
      const id = window.setInterval(()=>{
        step();
      }, 200);
      timerRef.current = id as unknown as number;
      return ()=> window.clearInterval(id);
    }
  },[running, cells]);

  const boxSize = clamp(480/size, 8, 24);

  return (
    <div className="w-full">
      <h3 className="text-lg font-semibold mb-2">ABM Sandbox: Schelling Segregation</h3>
      <p className="text-sm text-gray-700 mb-3">Illustrates how simple local preferences generate unintended macro-patterns. Tune parameters and watch clustering emerge. Use findings to define <em>failure envelopes</em> and edge interventions.</p>
      <div className="grid md:grid-cols-2 gap-4">
        <div>
          <div className="flex flex-wrap gap-3 items-center mb-3">
            <label className="text-sm">Grid: {size}×{size}
              <input type="range" min={10} max={30} value={size} onChange={e=>setSize(parseInt(e.target.value))} className="w-40 ml-2"/>
            </label>
            <label className="text-sm">Share A: {(shareA*100).toFixed(0)}%
              <input type="range" min={0.1} max={0.9} step={0.05} value={shareA} onChange={e=>setShareA(parseFloat(e.target.value))} className="w-40 ml-2"/>
            </label>
            <label className="text-sm">Vacancy: {(vacancy*100).toFixed(0)}%
              <input type="range" min={0.05} max={0.4} step={0.01} value={vacancy} onChange={e=>setVacancy(parseFloat(e.target.value))} className="w-40 ml-2"/>
            </label>
            <label className="text-sm">Similarity threshold: {(threshold*100).toFixed(0)}%
              <input type="range" min={0} max={0.8} step={0.05} value={threshold} onChange={e=>setThreshold(parseFloat(e.target.value))} className="w-40 ml-2"/>
            </label>
          </div>
          <div className="flex gap-2 mb-3">
            <button className="px-3 py-1.5 rounded bg-gray-900 text-white" onClick={reset}>Reset</button>
            <button className="px-3 py-1.5 rounded bg-blue-600 text-white" onClick={step}>Step</button>
            <button className="px-3 py-1.5 rounded bg-green-600 text-white" onClick={()=>setRunning(r=>!r)}>{running?"Pause":"Run"}</button>
          </div>
          <div style={{ width: boxSize*size, height: boxSize*size }} className="border rounded bg-white shadow">
            <div className="grid" style={{ gridTemplateColumns: `repeat(${size}, ${boxSize}px)` }}>
              {cells.map((c,i)=>{
                const bg = c===""?"bg-white border" : c==="A"?"bg-gray-800" : "bg-gray-400";
                const title = c===""?"Vacant": c;
                return <div key={i} title={title} className={`${bg} w-[${boxSize}px] h-[${boxSize}px]`}/>;
              })}
            </div>
          </div>
        </div>
        <div>
          <div className="p-3 border rounded bg-gray-50">
            <div className="text-sm">Iterations: <span className="font-mono">{iter}</span></div>
            <div className="text-sm">Moved last step: <span className="font-mono">{stats.moved}</span></div>
            <div className="text-sm">% Satisfied (agents above threshold): <span className="font-mono">{stats.sat.toFixed(1)}%</span></div>
            <div className="text-sm">Avg same-neighbor fraction: <span className="font-mono">{(stats.avgSame*100).toFixed(1)}%</span></div>
            <SegregationIndex cells={cells} size={size}/>
            <div className="mt-3 text-sm text-gray-700">
              <p className="mb-2"><strong>Interpretation:</strong> Rising neighbor-similarity shows emergent clustering—even without intent. To counter, change <em>search patterns</em> and <em>bridge frictions</em>, not identities. Publish this as the proof's <em>failure envelope</em> and specify edge interventions.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ---------- Proof Card Form & Views ----------

function FieldLabel({title, desc}:{title:string; desc?:string}){
  return (
    <div className="mb-1">
      <div className="text-sm font-semibold">{title}</div>
      {desc && <div className="text-xs text-gray-600">{desc}</div>}
    </div>
  );
}

function TextArea({value,onChange,rows=3,placeholder}:{value:string;onChange:(v:string)=>void;rows?:number;placeholder?:string}){
  return (
    <textarea value={value} onChange={e=>onChange(e.target.value)} rows={rows} placeholder={placeholder}
      className="w-full border rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"/>
  );
}

function TextInput({value,onChange,placeholder}:{value:string;onChange:(v:string)=>void;placeholder?:string}){
  return (
    <input value={value} onChange={e=>onChange(e.target.value)} placeholder={placeholder}
      className="w-full border rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"/>
  );
}

function NumberInput({value,onChange,min,max,step=1}:{value:number;onChange:(v:number)=>void;min?:number;max?:number;step?:number}){
  return (
    <input type="number" value={value} onChange={e=>onChange(parseFloat(e.target.value))} min={min} max={max} step={step}
      className="w-28 border rounded p-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"/>
  );
}

function OutcomeBandEditor({band,setBand}:{band:OutcomeBand; setBand:(b:OutcomeBand)=>void}){
  return (
    <div className="flex flex-wrap items-center gap-2">
      <label className="text-sm">Point:
        <input type="number" value={band.point} onChange={e=>setBand({...band, point: parseFloat(e.target.value)})}
          className="w-20 ml-1 border rounded p-1 text-sm"/>
      </label>
      <label className="text-sm">Low:
        <input type="number" value={band.low} onChange={e=>setBand({...band, low: parseFloat(e.target.value)})}
          className="w-20 ml-1 border rounded p-1 text-sm"/>
      </label>
      <label className="text-sm">High:
        <input type="number" value={band.high} onChange={e=>setBand({...band, high: parseFloat(e.target.value)})}
          className="w-20 ml-1 border rounded p-1 text-sm"/>
      </label>
      <label className="text-sm">Unit:
        <input value={band.unit} onChange={e=>setBand({...band, unit: e.target.value})}
          className="w-36 ml-1 border rounded p-1 text-sm"/>
      </label>
    </div>
  );
}

function Chip({label, onRemove}:{label:string; onRemove?:()=>void}){
  return (
    <span className="inline-flex items-center gap-1 bg-gray-200 text-gray-800 text-xs px-2 py-1 rounded-full mr-1 mb-1">{label}{onRemove && <button className="ml-1 text-gray-700 hover:text-black" onClick={onRemove}>×</button>}</span>
  );
}

function ArrayEditor({items,setItems,placeholder}:{items:string[]; setItems:(arr:string[])=>void; placeholder?:string}){
  const [val,setVal] = useState("");
  function add(){ if(val.trim()){ setItems([...items, val.trim()]); setVal(""); } }
  return (
    <div>
      <div className="flex gap-2 mb-2">
        <input value={val} onChange={e=>setVal(e.target.value)} placeholder={placeholder || "Add item"} className="flex-1 border rounded p-2 text-sm"/>
        <button className="px-3 py-1.5 rounded bg-gray-900 text-white" onClick={add}>Add</button>
      </div>
      <div>{items.map((it,i)=>(<Chip key={i} label={it} onRemove={()=>setItems(items.filter((_,j)=>j!==i))}/>))}</div>
    </div>
  );
}

function ProofCard({p}:{p:CapabilityProof}){
  return (
    <div className="border rounded-lg p-4 bg-white shadow-sm">
      <div className="flex justify-between items-start gap-2">
        <div>
          <h4 className="text-base font-semibold">{p.title}</h4>
          <div className="text-xs text-gray-600">Updated {new Date(p.updatedAt).toLocaleString()} • Steward: {p.steward}</div>
        </div>
        <div className="text-right">
          <div className="text-xs text-gray-600">Proof Level</div>
          <div className="text-lg font-bold">L{p.proofLevel}</div>
        </div>
      </div>
      <div className="grid md:grid-cols-2 gap-3 mt-3 text-sm">
        <div>
          <div><span className="font-semibold">Function:</span> {p.functionDesc}</div>
          <div><span className="font-semibold">Context:</span> {p.context} • <span className="font-semibold">Timeframe:</span> {p.timeframe}</div>
          <div><span className="font-semibold">Baseline:</span> {p.baselineDesc}</div>
          <div className="mt-1"><span className="font-semibold">Outcome band:</span> {fmtPct(p.outcomeBand.point)} ({fmtPct(p.outcomeBand.low)} to {fmtPct(p.outcomeBand.high)}) of {p.outcomeBand.unit}</div>
          <div className="mt-2">
            <div className="font-semibold">Protocol</div>
            <ul className="list-disc pl-5">
              {p.protocol.map((step,i)=>(<li key={i}>{step}</li>))}
            </ul>
          </div>
        </div>
        <div>
          <div><span className="font-semibold">Evidence design:</span> {p.evidenceDesign} {p.nParticipants?`• N=${p.nParticipants}`:""} {p.durationWeeks?`• ${p.durationWeeks} weeks`:""}</div>
          <div className="mt-2"><span className="font-semibold">Robustness checks:</span> {p.robustnessChecks.join("; ") || "—"}</div>
          <div className="mt-2"><span className="font-semibold">Fairness/side-effects:</span> {p.fairnessPanel || "—"}</div>
          <div className="mt-2"><span className="font-semibold">Identity safeguards:</span> {p.identitySafeguards.join("; ") || "—"}</div>
          <div className="mt-2"><span className="font-semibold">ATCF notes:</span> {p.atcfNotes || "—"}</div>
          <div className="mt-2"><span className="font-semibold">Failure envelope:</span> {p.failureEnvelope || "—"}</div>
          <div className="mt-2"><span className="font-semibold">Governance:</span> {p.governance || "—"}</div>
        </div>
      </div>
      <div className="mt-3 grid md:grid-cols-2 gap-3">
        <div className="p-2 bg-gray-50 rounded">
          <div className="text-xs uppercase text-gray-600">Translations</div>
          <div className="text-sm"><span className="font-semibold">Stewardship: </span>{p.translations.stewardship || "—"}</div>
          <div className="text-sm"><span className="font-semibold">Justice: </span>{p.translations.justice || "—"}</div>
          <div className="text-sm"><span className="font-semibold">Thrift: </span>{p.translations.thrift || "—"}</div>
          <div className="text-sm"><span className="font-semibold">Beauty: </span>{p.translations.beauty || "—"}</div>
        </div>
        <div className="p-2 bg-gray-50 rounded">
          <div className="text-xs uppercase text-gray-600">Score (informal)</div>
          <div className="text-2xl font-bold">{scoreProof(p)}</div>
          <div className="text-xs text-gray-600">Completeness, level, robustness, identity safety, translations</div>
        </div>
      </div>
    </div>
  );
}

function AuditTables({p, onUpdate}:{p:CapabilityProof; onUpdate:(p:CapabilityProof)=>void}){
  const [evPass,setEvPass] = useState<boolean | null>(null);
  const [evNotes,setEvNotes] = useState("");
  const [idPass,setIdPass] = useState<boolean | null>(null);
  const [idNotes,setIdNotes] = useState("");

  useEffect(()=>{
    // prefill from adversarial findings if present
    if (p.adversarialFindings) setEvNotes(p.adversarialFindings);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  },[]);

  return (
    <div className="grid md:grid-cols-2 gap-4 text-sm">
      <div className="border rounded p-3 bg-white">
        <div className="font-semibold mb-2">Table 1: Evidence vs Outcome Band</div>
        <div className="mb-2">Does the evidence justify the claimed band?</div>
        <div className="flex gap-2 mb-2">
          <button className={`px-3 py-1.5 rounded ${evPass===true?"bg-green-600 text-white":"bg-gray-200"}`} onClick={()=>setEvPass(true)}>Pass</button>
          <button className={`px-3 py-1.5 rounded ${evPass===false?"bg-red-600 text-white":"bg-gray-200"}`} onClick={()=>setEvPass(false)}>Fail</button>
          <button className={`px-3 py-1.5 rounded ${evPass===null?"bg-gray-900 text-white":"bg-gray-200"}`} onClick={()=>setEvPass(null)}>Unset</button>
        </div>
        <TextArea value={evNotes} onChange={setEvNotes} rows={5} placeholder="Notes: design choice, biases, replication, sensitivity…"/>
      </div>
      <div className="border rounded p-3 bg-white">
        <div className="font-semibold mb-2">Table 2: Identity / Soul-Safety (ATCF)</div>
        <div className="mb-2">Are identity safeguards adequate?</div>
        <div className="flex gap-2 mb-2">
          <button className={`px-3 py-1.5 rounded ${idPass===true?"bg-green-600 text-white":"bg-gray-200"}`} onClick={()=>setIdPass(true)}>Pass</button>
          <button className={`px-3 py-1.5 rounded ${idPass===false?"bg-red-600 text-white":"bg-gray-200"}`} onClick={()=>setIdPass(false)}>Fail</button>
          <button className={`px-3 py-1.5 rounded ${idPass===null?"bg-gray-900 text-white":"bg-gray-200"}`} onClick={()=>setIdPass(null)}>Unset</button>
        </div>
        <TextArea value={idNotes} onChange={setIdNotes} rows={5} placeholder="Notes: opt-in clarity, exit symmetry, role choice, dignity lines…"/>
      </div>
    </div>
  );
}

function ProofForm({onSave, initial}:{onSave:(p:CapabilityProof)=>void; initial?:CapabilityProof}){
  const [title,setTitle] = useState(initial?.title || "");
  const [functionDesc,setFunctionDesc] = useState(initial?.functionDesc || "");
  const [context,setContext] = useState(initial?.context || "");
  const [timeframe,setTimeframe] = useState(initial?.timeframe || "");
  const [baselineDesc,setBaselineDesc] = useState(initial?.baselineDesc || "");
  const [outcomeBand,setOutcomeBand] = useState<OutcomeBand>(initial?.outcomeBand || {point:0,low:0,high:0,unit:"%"});
  const [protocol,setProtocol] = useState<string[]>(initial?.protocol || []);
  const [evidenceDesign,setEvidenceDesign] = useState(initial?.evidenceDesign || "");
  const [nParticipants,setNParticipants] = useState(initial?.nParticipants || 0);
  const [durationWeeks,setDurationWeeks] = useState(initial?.durationWeeks || 0);
  const [robustness,setRobustness] = useState<string[]>(initial?.robustnessChecks || []);
  const [fairnessPanel,setFairnessPanel] = useState(initial?.fairnessPanel || "");
  const [identitySafeguards,setIdentitySafeguards] = useState<string[]>(initial?.identitySafeguards || []);
  const [atcfNotes,setAtcfNotes] = useState(initial?.atcfNotes || "");
  const [governance,setGovernance] = useState(initial?.governance || "");
  const [failureEnvelope,setFailureEnvelope] = useState(initial?.failureEnvelope || "");
  const [proofLevel,setProofLevel] = useState<ProofLevel>(initial?.proofLevel || 0);
  const [steward,setSteward] = useState(initial?.steward || "");
  const [translations,setTranslations] = useState(initial?.translations || {});

  function save(){
    const p: CapabilityProof = {
      id: initial?.id || uid(),
      title, functionDesc, context, timeframe,
      outcomeBand, baselineDesc, protocol,
      evidenceDesign, nParticipants, durationWeeks,
      robustnessChecks: robustness,
      fairnessPanel, identitySafeguards, atcfNotes,
      governance, failureEnvelope, proofLevel, steward,
      updatedAt: nowISO(), translations,
    };
    onSave(p);
  }

  const valid = title && functionDesc && context && timeframe && outcomeBand.unit && protocol.length>=3 && evidenceDesign && governance && failureEnvelope && steward;

  return (
    <div className="border rounded-lg p-4 bg-white">
      <h3 className="text-lg font-semibold mb-3">Create / Edit Capability Proof</h3>
      <div className="grid md:grid-cols-2 gap-4">
        <div>
          <FieldLabel title="Title"/><TextInput value={title} onChange={setTitle} placeholder="Concise title"/>
          <FieldLabel title="Function" desc="What do you reliably do?"/><TextArea value={functionDesc} onChange={setFunctionDesc} rows={2}/>
          <FieldLabel title="Context" desc="Where/for whom/with what constraints"/><TextArea value={context} onChange={setContext} rows={2}/>
          <FieldLabel title="Timeframe"/><TextInput value={timeframe} onChange={setTimeframe} placeholder="e.g., 16 weeks"/>
          <FieldLabel title="Baseline"/><TextArea value={baselineDesc} onChange={setBaselineDesc}/>
          <FieldLabel title="Outcome band" desc="Point, low, high, and unit"/>
          <OutcomeBandEditor band={outcomeBand} setBand={setOutcomeBand}/>
          <div className="mt-2"><span className="text-xs text-gray-600">Tip: use negative values for reductions (e.g., -27%).</span></div>
        </div>
        <div>
          <FieldLabel title="Protocol (5–9 steps)"/><ArrayEditor items={protocol} setItems={setProtocol} placeholder="Add protocol step"/>
          <FieldLabel title="Evidence design"/><TextInput value={evidenceDesign} onChange={setEvidenceDesign} placeholder="e.g., stepped-wedge; matched cohorts; pre-registered"/>
          <div className="flex gap-3 items-center mt-2">
            <div><span className="text-sm">N:</span> <NumberInput value={nParticipants||0} onChange={setNParticipants} min={0}/></div>
            <div><span className="text-sm">Duration (weeks):</span> <NumberInput value={durationWeeks||0} onChange={setDurationWeeks} min={0}/></div>
          </div>
          <FieldLabel title="Robustness checks"/><ArrayEditor items={robustness} setItems={setRobustness} placeholder="Add check (replication, sensitivity, ablation)"/>
          <FieldLabel title="Fairness / side-effects"/><TextArea value={fairnessPanel} onChange={setFairnessPanel}/>
          <FieldLabel title="Identity safeguards"/><ArrayEditor items={identitySafeguards} setItems={setIdentitySafeguards} placeholder="Add safeguard (opt-in, exit symmetry, role choice)"/>
          <FieldLabel title="ATCF notes"/><TextArea value={atcfNotes} onChange={setAtcfNotes}/>
          <FieldLabel title="Governance & monitoring"/><TextArea value={governance} onChange={setGovernance}/>
          <FieldLabel title="Failure envelope"/><TextArea value={failureEnvelope} onChange={setFailureEnvelope}/>
          <div className="grid grid-cols-2 gap-3 mt-2">
            <div>
              <FieldLabel title="Proof level"/>
              <select value={proofLevel} onChange={e=>setProofLevel(parseInt(e.target.value) as ProofLevel)} className="w-full border rounded p-2 text-sm">
                <option value={0}>L0 — Seed</option>
                <option value={1}>L1 — Sprout</option>
                <option value={2}>L2 — Branch</option>
                <option value={3}>L3 — Grove</option>
                <option value={4}>L4 — Standard</option>
              </select>
            </div>
            <div>
              <FieldLabel title="Steward"/>
              <TextInput value={steward} onChange={setSteward} placeholder="Responsible person/team"/>
            </div>
          </div>
          <div className="mt-3">
            <FieldLabel title="Translations (render same win in multiple moral grammars)"/>
            <div className="grid grid-cols-2 gap-2">
              <div>
                <div className="text-xs text-gray-600">Stewardship</div>
                <TextArea value={translations.stewardship||""} onChange={v=>setTranslations({...translations, stewardship:v})}/>
              </div>
              <div>
                <div className="text-xs text-gray-600">Justice</div>
                <TextArea value={translations.justice||""} onChange={v=>setTranslations({...translations, justice:v})}/>
              </div>
              <div>
                <div className="text-xs text-gray-600">Thrift</div>
                <TextArea value={translations.thrift||""} onChange={v=>setTranslations({...translations, thrift:v})}/>
              </div>
              <div>
                <div className="text-xs text-gray-600">Beauty</div>
                <TextArea value={translations.beauty||""} onChange={v=>setTranslations({...translations, beauty:v})}/>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div className="mt-4 flex gap-2">
        <button className={`px-3 py-1.5 rounded ${valid?"bg-gray-900 text-white":"bg-gray-300 text-gray-600 cursor-not-allowed"}`} disabled={!valid} onClick={save}>Save Proof</button>
      </div>
    </div>
  );
}

// ---------- Main App ----------

type Tab = "gallery" | "create" | "audit" | "translate" | "abm";

export default function CapabilityProofsApp(){
  const [proofs,setProofs] = useState<CapabilityProof[]>(()=>loadProofsLS());
  const [active,setActive] = useState<Tab>("gallery");
  const [selectedId,setSelectedId] = useState<string | null>(proofs[0]?.id || null);

  useEffect(()=>{ saveProofsLS(proofs); },[proofs]);
  useEffect(()=>{ if(proofs.length && !selectedId) setSelectedId(proofs[0].id); },[proofs,selectedId]);

  function addOrUpdate(p: CapabilityProof){
    setProofs(prev=>{
      const idx = prev.findIndex(q=>q.id===p.id);
      if (idx>=0){ const next = prev.slice(); next[idx] = p; return next; }
      return [p, ...prev];
    });
    setActive("gallery");
    setSelectedId(p.id);
  }

  function remove(id: string){
    setProofs(prev=>prev.filter(p=>p.id!==id));
    if (selectedId===id) setSelectedId(null);
  }

  function exportJSON(){
    const blob = new Blob([JSON.stringify(proofs,null,2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "amc_capability_proofs.json"; a.click(); URL.revokeObjectURL(url);
  }

  function importJSON(ev: React.ChangeEvent<HTMLInputElement>){
    const file = ev.target.files?.[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try { const parsed = JSON.parse(String(reader.result)); if(Array.isArray(parsed)) setProofs(parsed); }
      catch {}
    };
    reader.readAsText(file);
  }

  function loadExamples(){
    const ex = exampleProofs();
    setProofs(prev=>[...ex, ...prev]);
    setSelectedId(ex[0].id);
    setActive("gallery");
  }

  const selected = proofs.find(p=>p.id===selectedId) || null;

  return (
    <div className="p-4 md:p-6 max-w-6xl mx-auto">
      <header className="mb-4">
        <h1 className="text-2xl font-bold">AMC Capability Proofs – Teaching App (Prototype)</h1>
        <p className="text-gray-700 text-sm">Prove small. Publish bands. Protect identity. Replicate. Translate. Repair at the edges.</p>
      </header>

      <nav className="flex flex-wrap gap-2 mb-4">
        {([
          ["gallery","Gallery"],
          ["create","Create Proof"],
          ["audit","Audit"],
          ["translate","Translation Studio"],
          ["abm","ABM Sandbox"],
        ] as [Tab,string][]).map(([key,label])=> (
          <button key={key} onClick={()=>setActive(key)}
            className={`px-3 py-1.5 rounded ${active===key?"bg-gray-900 text-white":"bg-gray-200"}`}>{label}</button>
        ))}
        <div className="flex-1"/>
        <button onClick={loadExamples} className="px-3 py-1.5 rounded bg-amber-500 text-white">Load Example Proofs</button>
        <button onClick={exportJSON} className="px-3 py-1.5 rounded bg-gray-900 text-white">Export JSON</button>
        <label className="px-3 py-1.5 rounded bg-gray-200 cursor-pointer">Import
          <input type="file" accept="application/json" onChange={importJSON} className="hidden"/>
        </label>
      </nav>

      {active==="gallery" && (
        <div className="grid md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <div className="border rounded p-3 bg-white">
              <div className="text-sm font-semibold mb-2">Proofs</div>
              {proofs.length===0 && <div className="text-sm text-gray-600">No proofs yet. Load examples or create one.</div>}
              <ul className="divide-y">
                {proofs.map(p=> (
                  <li key={p.id} className={`py-2 flex items-center justify-between ${selectedId===p.id?"bg-gray-50":""}`}>
                    <button className="text-left flex-1 px-2" onClick={()=>setSelectedId(p.id)}>
                      <div className="font-medium">{p.title}</div>
                      <div className="text-xs text-gray-600">L{p.proofLevel} • Score {scoreProof(p)} • {p.outcomeBand.unit} {fmtPct(p.outcomeBand.point)}</div>
                    </button>
                    <button className="px-2 py-1 text-xs rounded bg-red-100 text-red-700" onClick={()=>remove(p.id)}>Delete</button>
                  </li>
                ))}
              </ul>
            </div>
            {selected && (
              <div className="border rounded p-3 bg-white">
                <div className="text-sm font-semibold mb-2">Adversarial Audit</div>
                <TextArea value={selected.adversarialFindings||""} onChange={(v)=>{
                  const next = {...selected, adversarialFindings: v, updatedAt: nowISO()};
                  setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                }} rows={6} placeholder="Try to break this claim. What could be wrong or fragile?"/>
              </div>
            )}
          </div>
          <div>
            {selected ? <ProofCard p={selected}/> : <div className="text-sm text-gray-600">Select a proof to preview.</div>}
          </div>
        </div>
      )}

      {active==="create" && (
        <ProofForm onSave={addOrUpdate} initial={undefined}/>
      )}

      {active==="audit" && (
        selected ? (
          <div className="space-y-3">
            <ProofCard p={selected}/>
            <AuditTables p={selected} onUpdate={(p)=>addOrUpdate(p)}/>
          </div>
        ) : <div className="text-sm text-gray-600">Select a proof in the Gallery first.</div>
      )}

      {active==="translate" && (
        selected ? (
          <div className="grid md:grid-cols-2 gap-4">
            <div className="border rounded p-3 bg-white">
              <div className="font-semibold mb-2">Translation Studio</div>
              <div className="text-xs text-gray-600 mb-2">Render the <em>same verified outcome</em> in multiple moral grammars without lying.</div>
              <div className="space-y-2">
                <div>
                  <div className="text-xs text-gray-600">Stewardship</div>
                  <TextArea value={selected.translations.stewardship||""} onChange={(v)=>{
                    const next = {...selected, translations: {...selected.translations, stewardship: v}, updatedAt: nowISO()};
                    setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                  }}/>
                </div>
                <div>
                  <div className="text-xs text-gray-600">Justice</div>
                  <TextArea value={selected.translations.justice||""} onChange={(v)=>{
                    const next = {...selected, translations: {...selected.translations, justice: v}, updatedAt: nowISO()};
                    setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                  }}/>
                </div>
                <div>
                  <div className="text-xs text-gray-600">Thrift</div>
                  <TextArea value={selected.translations.thrift||""} onChange={(v)=>{
                    const next = {...selected, translations: {...selected.translations, thrift: v}, updatedAt: nowISO()};
                    setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                  }}/>
                </div>
                <div>
                  <div className="text-xs text-gray-600">Beauty</div>
                  <TextArea value={selected.translations.beauty||""} onChange={(v)=>{
                    const next = {...selected, translations: {...selected.translations, beauty: v}, updatedAt: nowISO()};
                    setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                  }}/>
                </div>
              </div>
            </div>
            <div>
              <ProofCard p={selected}/>
            </div>
          </div>
        ) : <div className="text-sm text-gray-600">Select a proof in the Gallery first.</div>
      )}

      {active==="abm" && (
        <ABMSandbox/>
      )}

      <footer className="mt-8 text-xs text-gray-500">
        <div>Prototype: AMC Capability Proofs • Keep the center simple. Let complexity live at the edges. Instrument edges. Repair quickly.</div>
      </footer>
    </div>
  );
}
