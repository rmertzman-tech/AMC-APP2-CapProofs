<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AMC Capability Proofs – Teaching App (Prototype)</title>
  <!-- Tailwind (CDN, for prototyping) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD + Babel Standalone (so we can run TSX in a single file) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <script type="text/babel" data-presets="typescript,react">
    const { useState, useEffect, useMemo } = React;

    // ---------- Types (TS annotations will be stripped by Babel) ----------
    type OutcomeBand = {
      point: number;
      low: number;
      high: number;
      unit: string;
    };
    type ProofLevel = 0 | 1 | 2 | 3 | 4;
    type RubricSelection = "Exemplary" | "Proficient" | "Basic" | "Missing";
    type RubricState = { selections: Record<string, RubricSelection>; notes?: string; total?: number; };
    type CapabilityProof = {
      id: string;
      title: string;
      functionDesc: string;
      context: string;
      timeframe: string;
      outcomeBand: OutcomeBand;
      baselineDesc: string;
      protocol: string[];
      evidenceDesign: string;
      nParticipants?: number;
      durationWeeks?: number;
      robustnessChecks: string[];
      fairnessPanel: string;
      identitySafeguards: string[];
      atcfNotes: string;
      governance: string;
      failureEnvelope: string;
      proofLevel: ProofLevel;
      steward: string;
      updatedAt: string;
      translations: { stewardship?: string; justice?: string; thrift?: string; beauty?: string; };
      adversarialFindings?: string;
      rubric?: RubricState;
    };

    // ---------- Utilities ----------
    function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
    function clamp(n:number,min:number,max:number){ return Math.max(min, Math.min(max, n)); }
    function fmtPct(n:number){ const sign = n>0? "+":""; return `${sign}${n.toFixed(1)}%`; }
    function nowISO(){ return new Date().toISOString(); }

    function scoreProof(p: CapabilityProof){
      let score = 0;
      const filledCore = [p.title, p.functionDesc, p.context, p.outcomeBand, p.protocol[0], p.evidenceDesign, p.governance, p.failureEnvelope].every(Boolean);
      score += filledCore ? 25 : 10;
      score += (p.proofLevel * 12);
      score += clamp(p.robustnessChecks.length * 4, 0, 20);
      score += clamp(p.identitySafeguards.length * 4, 0, 20);
      const tCount = [p.translations.stewardship, p.translations.justice, p.translations.thrift, p.translations.beauty].filter(Boolean).length;
      score += clamp(tCount * 3, 0, 12);
      return clamp(score, 0, 100);
    }

    // ---------- Example Proofs ----------
    function exampleProofs(): CapabilityProof[] {
      const ex1: CapabilityProof = {
        id: uid(),
        title: "Clinic No-Show Reduction (Urban A/B)",
        functionDesc: "Reduce missed specialist appointments",
        context: "Urban clinics A/B; adults 18–64",
        timeframe: "16 weeks",
        outcomeBand: { point: -27, low: -19, high: -35, unit: "% no-shows" },
        baselineDesc: "Baseline averaged 28% no-show over prior 12 weeks",
        protocol: [
          "Pre-visit SMS reminders with respectful language",
          "Peer navigator outreach for barrier triage",
          "Transit voucher offered; no pressure to accept",
          "Opt-out respected at each contact",
          "Follow-up nudge 24h post-visit for rescheduling"
        ],
        evidenceDesign: "Stepped-wedge rollout with matched control weeks; pre-registered",
        nParticipants: 840,
        durationWeeks: 16,
        robustnessChecks: [
          "Second-site replication achieved −24%",
          "Sensitivity to weekends and weather",
          "Ablation: removing transit voucher collapses effect"
        ],
        fairnessPanel: "No differential harm detected; translated materials added",
        identitySafeguards: [
          "Clear opt-in/opt-out",
          "Navigator language/gender choice when requested",
          "Audit for coercion; none reported"
        ],
        atcfNotes: "Exit-rate symmetry within 1.1×; no identity-pressure complaints",
        governance: "Weekly metrics review; stop rule if complaints >2% or exit asymmetry >1.5×",
        failureEnvelope: "Rural sites without transit partners; effect collapses",
        proofLevel: 2,
        steward: "Dr. R. Alvarez",
        updatedAt: nowISO(),
        translations: {
          stewardship: "We honor patients' time: fewer wasted trips, more kept promises.",
          justice: "Barriers fall hardest on the vulnerable; we remove them without pressure.",
          thrift: "Every kept appointment saves downstream costs for all of us.",
          beauty: "Care that arrives on time feels like dignity made visible."
        },
        adversarialFindings: "Watch holiday weeks; effect narrows."
      };

      const ex2: CapabilityProof = {
        id: uid(),
        title: "Neighborhood Peak Shaving (6 Blocks)",
        functionDesc: "Reduce peak-hour electricity demand",
        context: "Mixed-income neighborhood; summer evenings 6–9pm",
        timeframe: "12 weeks",
        outcomeBand: { point: -40, low: -35, high: -45, unit: "% peak kW" },
        baselineDesc: "Smart meter baseline from prior summer",
        protocol: [
          "Appliance timer kits with opt-in setup",
          "Micro-grid coordination for shared storage",
          "Voluntary 'quiet hour' social norm",
          "Weekly feedback cards to households"
        ],
        evidenceDesign: "Season-over-season with independent meter audit; synthetic control blocks",
        nParticipants: 210,
        durationWeeks: 12,
        robustnessChecks: [
          "Two-season stability within band",
          "Independent audit verifies readings"
        ],
        fairnessPanel: "No rebound burden; incentives scaled by income",
        identitySafeguards: ["No required schedule change", "Opt-out any time"],
        atcfNotes: "Participants define dignity lines; no reports of social shaming",
        governance: "Energy guild oversight; stop if complaints >1.5%",
        failureEnvelope: "Landlord–tenant split incentive weakens participation",
        proofLevel: 2,
        steward: "Energy Guild #4",
        updatedAt: nowISO(),
        translations: {
          stewardship: "We care for the grid like a commons.",
          justice: "Lower bills and fewer outages for those who bear the worst.",
          thrift: "Cheaper than building new peaker plants.",
          beauty: "Evening streets hum softer, and sleep comes easier."
        }
      };

      const ex3: CapabilityProof = {
        id: uid(),
        title: "Schelling-Aware Housing Mix",
        functionDesc: "Reduce emergent clustering without restricting choice",
        context: "City districts with diverse demographics",
        timeframe: "3 quarters",
        outcomeBand: { point: -32, low: -25, high: -40, unit: "% clustering index" },
        baselineDesc: "Pre-policy clustering index",
        protocol: [
          "Expand default search radius in housing portal",
          "Seed mixed-amenity hubs",
          "Incentivize 'bridge groups' to ease cross-tract moves",
          "Quarterly edge metrics with public dashboards"
        ],
        evidenceDesign: "ABM sandbox preview + staged rollout across districts",
        nParticipants: 1200,
        durationWeeks: 36,
        robustnessChecks: [
          "Cross-district replication",
          "Sensitivity to transit access"
        ],
        fairnessPanel: "No penalties for choices; only added options/incentives",
        identitySafeguards: ["Freedom of choice preserved", "No pressure to relocate"],
        atcfNotes: "Identity-respecting incentives only",
        governance: "Civic lab monitors edge metrics; stop if dissatisfaction >2%",
        failureEnvelope: "Poor transit undermines effect; pivot to mobility first",
        proofLevel: 1,
        steward: "City Civic Lab",
        updatedAt: nowISO(),
        translations: {
          stewardship: "We tend our neighborhoods like gardens, avoiding monocultures.",
          justice: "Open more doors, not fewer; remove friction, not freedom.",
          thrift: "Smarter search beats costly mandates.",
          beauty: "Variety makes a city sing."
        }
      };

      return [ex1, ex2, ex3];
    }

    // ---------- Local Storage ----------
    const LS_KEY = "amc_proofs_v1";
    function loadProofsLS(): CapabilityProof[] { try { const raw = localStorage.getItem(LS_KEY); if(!raw) return []; return JSON.parse(raw); } catch { return []; } }
    function saveProofsLS(proofs: CapabilityProof[]){ try { localStorage.setItem(LS_KEY, JSON.stringify(proofs)); } catch {} }

    // ---------- Shareable Links (URL hash) ----------
    function encodeState(obj:any):string{ try{ const json = JSON.stringify(obj); return btoa(unescape(encodeURIComponent(json))); } catch { return ""; } }
    function decodeState<T=any>(s:string):T|null{ try { const json = decodeURIComponent(escape(atob(s))); return JSON.parse(json); } catch { return null; } }
    function makeProofLink(p:CapabilityProof){ const payload = { proof: p }; return `${location.origin}${location.pathname}#p=${encodeState(payload)}`; }
    function makeGalleryLink(proofs:CapabilityProof[]){ const slim = proofs.map(({adversarialFindings, rubric, ...rest})=>rest); const payload = { gallery: slim }; return `${location.origin}${location.pathname}#g=${encodeState(payload)}`; }
    function parseHash(): {proof?:CapabilityProof; gallery?:CapabilityProof[]} | null {
      if (!location.hash) return null; const h = location.hash.slice(1);
      if (h.startsWith("p=")) { const data = decodeState<{proof:CapabilityProof}>(h.slice(2)); return data || null; }
      if (h.startsWith("g=")) { const data = decodeState<{gallery:CapabilityProof[]}>(h.slice(2)); return data || null; }
      return null;
    }

    // ---------- ABM: Schelling Sandbox ----------
    type Cell = "A" | "B" | "";
    function generateGrid(size:number, shareA:number, vacancy:number): Cell[] {
      const total = size*size; const numEmpty = Math.round(total*vacancy); const numAgents = total - numEmpty; const numA = Math.round(numAgents*shareA); const numB = numAgents - numA; const cells: Cell[] = Array(total).fill("");
      let pool: Cell[] = [ ...Array(numA).fill("A"), ...Array(numB).fill("B"), ...Array(numEmpty).fill("") ];
      for (let i=0;i<total;i++){ const idx = Math.floor(Math.random()*pool.length); cells[i] = pool[idx]; pool.splice(idx,1);} return cells;
    }
    function neighbors(idx:number, size:number):number[]{ const x = idx % size, y = Math.floor(idx/size); const res:number[] = []; for (let dy=-1; dy<=1; dy++){ for (let dx=-1; dx<=1; dx++){ if (dx===0 && dy===0) continue; const nx=x+dx, ny=y+dy; if (nx>=0 && nx<size && ny>=0 && ny<size) res.push(ny*size+nx);} } return res; }
    function stepSchelling(cells:Cell[], size:number, simThresh:number){
      const empties:number[] = []; const unsatisfied:number[] = []; let satisfiedCount=0; let totalSameFrac=0; for (let i=0;i<cells.length;i++){ const c=cells[i]; if (c===""){ empties.push(i); continue; } const ns=neighbors(i,size); let like=0, tot=0; for (const j of ns){ if (cells[j]!==""){ tot++; if (cells[j]===c) like++; } } const frac= tot===0 ? 1 : like/tot; totalSameFrac += frac; if (frac>=simThresh){ satisfiedCount++; } else { unsatisfied.push(i); } }
      const newCells=cells.slice(); let moved=0; for (let k=unsatisfied.length-1;k>0;k--){ const r=Math.floor(Math.random()*(k+1)); [unsatisfied[k], unsatisfied[r]] = [unsatisfied[r], unsatisfied[k]]; }
      for (const i of unsatisfied){ if (empties.length===0) break; const c=newCells[i]; if (c==="") continue; const eIdx=Math.floor(Math.random()*empties.length); const to=empties[eIdx]; empties.splice(eIdx,1); newCells[to]=c; newCells[i]=""; empties.push(i); moved++; }
      const satisfiedPct = (satisfiedCount / (cells.length - empties.length)) * 100; const avgSame = totalSameFrac / (cells.length - empties.length); return { cells:newCells, moved, satisfiedPct, avgSame };
    }
    function SegregationIndex({cells, size}:{cells:Cell[]; size:number}){
      let same=0, tot=0; for (let i=0;i<cells.length;i++){ const c=cells[i]; if (c==="") continue; for (const j of neighbors(i,size)){ if (j>i && cells[j]!==""){ tot++; if (cells[j]===c) same++; } } } const frac = tot===0?0:same/tot; return (<div className="text-sm text-gray-700 mt-1">Segregation index (neighbor similarity): {(frac*100).toFixed(1)}%</div>);
    }
    function ABMSandbox(){
      const [size,setSize] = useState(20); const [shareA,setShareA]=useState(0.5); const [vacancy,setVacancy]=useState(0.2); const [threshold,setThreshold]=useState(0.3);
      const [cells,setCells] = useState(()=>generateGrid(20,0.5,0.2)); const [iter,setIter]=useState(0); const [running,setRunning]=useState(false);
      const [stats,setStats]=useState({moved:0,sat:0,avgSame:0});
      function reset(){ setCells(generateGrid(size,shareA,vacancy)); setIter(0); setStats({moved:0,sat:0,avgSame:0}); setRunning(false); }
      function step(){ const {cells:c2, moved, satisfiedPct, avgSame} = stepSchelling(cells,size,threshold); setCells(c2); setIter(it=>it+1); setStats({moved, sat:satisfiedPct, avgSame}); }
      useEffect(()=>{ reset(); },[size,shareA,vacancy]);
      useEffect(()=>{ let id:number|undefined; if (running){ id = window.setInterval(()=>{ step(); }, 200); } return ()=>{ if(id) window.clearInterval(id); }; },[running, cells]);
      const boxSize = clamp(480/size, 8, 24);
      return (
        <div className="w-full">
          <h3 className="text-lg font-semibold mb-2">ABM Sandbox: Schelling Segregation</h3>
          <p className="text-sm text-gray-700 mb-3">Illustrates how simple local preferences generate unintended macro-patterns. Tune parameters and watch clustering emerge. Use findings to define <em>failure envelopes</em> and edge interventions.</p>
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <div className="flex flex-wrap gap-3 items-center mb-3">
                <label className="text-sm">Grid: {size}×{size}
                  <input type="range" min={10} max={30} value={size} onChange={e=>setSize(parseInt(e.target.value))} className="w-40 ml-2"/>
                </label>
                <label className="text-sm">Share A: {(shareA*100).toFixed(0)}%
                  <input type="range" min={0.1} max={0.9} step={0.05} value={shareA} onChange={e=>setShareA(parseFloat(e.target.value))} className="w-40 ml-2"/>
                </label>
                <label className="text-sm">Vacancy: {(vacancy*100).toFixed(0)}%
                  <input type="range" min={0.05} max={0.4} step={0.01} value={vacancy} onChange={e=>setVacancy(parseFloat(e.target.value))} className="w-40 ml-2"/>
                </label>
                <label className="text-sm">Similarity threshold: {(threshold*100).toFixed(0)}%
                  <input type="range" min={0} max={0.8} step={0.05} value={threshold} onChange={e=>setThreshold(parseFloat(e.target.value))} className="w-40 ml-2"/>
                </label>
              </div>
              <div className="flex gap-2 mb-3">
                <button className="px-3 py-1.5 rounded bg-gray-900 text-white" onClick={reset}>Reset</button>
                <button className="px-3 py-1.5 rounded bg-blue-600 text-white" onClick={step}>Step</button>
                <button className="px-3 py-1.5 rounded bg-green-600 text-white" onClick={()=>setRunning(r=>!r)}>{running?"Pause":"Run"}</button>
              </div>
              <div style={{ width: boxSize*size, height: boxSize*size }} className="border rounded bg-white shadow">
                <div className="grid" style={{ gridTemplateColumns: `repeat(${size}, ${boxSize}px)` }}>
                  {cells.map((c,i)=>{
                    const bg = c===""?"#ffffff" : c==="A"?"#111827" : "#9ca3af";
                    return <div key={i} title={c===""?"Vacant": c} style={{ width: boxSize, height: boxSize, background: bg, border: c===""?"1px solid #e5e7eb":"none"}}/>;
                  })}
                </div>
              </div>
            </div>
            <div>
              <div className="p-3 border rounded bg-gray-50">
                <div className="text-sm">Iterations: <span className="font-mono">{iter}</span></div>
                <div className="text-sm">Moved last step: <span className="font-mono">{stats.moved}</span></div>
                <div className="text-sm">% Satisfied (agents above threshold): <span className="font-mono">{stats.sat.toFixed(1)}%</span></div>
                <div className="text-sm">Avg same-neighbor fraction: <span className="font-mono">{(stats.avgSame*100).toFixed(1)}%</span></div>
                <SegregationIndex cells={cells} size={size}/>
                <div className="mt-3 text-sm text-gray-700">
                  <p className="mb-2"><strong>Interpretation:</strong> Rising neighbor-similarity shows emergent clustering—even without intent. To counter, change <em>search patterns</em> and <em>bridge frictions</em>, not identities. Publish this as the proof's <em>failure envelope</em> and specify edge interventions.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // ---------- Common UI helpers ----------
    function FieldLabel({title, desc}:{title:string; desc?:string}){
      return (
        <div className="mb-1">
          <div className="text-sm font-semibold">{title}</div>
          {desc && <div className="text-xs text-gray-600">{desc}</div>}
        </div>
      );
    }
    function TextArea({value,onChange,rows=3,placeholder}:{value:string;onChange:(v:string)=>void;rows?:number;placeholder?:string}){
      return (<textarea value={value} onChange={e=>onChange(e.target.value)} rows={rows} placeholder={placeholder} className="w-full border rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"/>);
    }
    function TextInput({value,onChange,placeholder}:{value:string;onChange:(v:string)=>void;placeholder?:string}){
      return (<input value={value} onChange={e=>onChange(e.target.value)} placeholder={placeholder} className="w-full border rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"/>);
    }
    function NumberInput({value,onChange,min,max,step=1}:{value:number;onChange:(v:number)=>void;min?:number;max?:number;step?:number}){
      return (<input type="number" value={value} onChange={e=>onChange(parseFloat(e.target.value))} min={min} max={max} step={step} className="w-28 border rounded p-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"/>);
    }
    function Chip({label, onRemove}:{label:string; onRemove?:()=>void}){
      return (<span className="inline-flex items-center gap-1 bg-gray-200 text-gray-800 text-xs px-2 py-1 rounded-full mr-1 mb-1">{label}{onRemove && <button className="ml-1 text-gray-700 hover:text-black" onClick={onRemove}>×</button>}</span>);
    }
    function ArrayEditor({items,setItems,placeholder}:{items:string[]; setItems:(arr:string[])=>void; placeholder?:string}){
      const [val,setVal] = useState(""); function add(){ if(val.trim()){ setItems([...items, val.trim()]); setVal(""); } }
      return (
        <div>
          <div className="flex gap-2 mb-2">
            <input value={val} onChange={e=>setVal(e.target.value)} placeholder={placeholder || "Add item"} className="flex-1 border rounded p-2 text-sm"/>
            <button className="px-3 py-1.5 rounded bg-gray-900 text-white" onClick={add}>Add</button>
          </div>
          <div>{items.map((it,i)=>(<Chip key={i} label={it} onRemove={()=>setItems(items.filter((_,j)=>j!==i))}/>))}</div>
        </div>
      );
    }

    function ProofCard({p}:{p:CapabilityProof}){
      return (
        <div className="border rounded-lg p-4 bg-white shadow-sm">
          <div className="flex justify-between items-start gap-2">
            <div>
              <h4 className="text-base font-semibold">{p.title}</h4>
              <div className="text-xs text-gray-600">Updated {new Date(p.updatedAt).toLocaleString()} • Steward: {p.steward}</div>
            </div>
            <div className="text-right">
              <div className="text-xs text-gray-600">Proof Level</div>
              <div className="text-lg font-bold">L{p.proofLevel}</div>
            </div>
          </div>
          <div className="grid md:grid-cols-2 gap-3 mt-3 text-sm">
            <div>
              <div><span className="font-semibold">Function:</span> {p.functionDesc}</div>
              <div><span className="font-semibold">Context:</span> {p.context} • <span className="font-semibold">Timeframe:</span> {p.timeframe}</div>
              <div><span className="font-semibold">Baseline:</span> {p.baselineDesc}</div>
              <div className="mt-1"><span className="font-semibold">Outcome band:</span> {fmtPct(p.outcomeBand.point)} ({fmtPct(p.outcomeBand.low)} to {fmtPct(p.outcomeBand.high)}) of {p.outcomeBand.unit}</div>
              <div className="mt-2">
                <div className="font-semibold">Protocol</div>
                <ul className="list-disc pl-5">{p.protocol.map((step,i)=>(<li key={i}>{step}</li>))}</ul>
              </div>
            </div>
            <div>
              <div><span className="font-semibold">Evidence design:</span> {p.evidenceDesign} {p.nParticipants?`• N=${p.nParticipants}`:""} {p.durationWeeks?`• ${p.durationWeeks} weeks`:""}</div>
              <div className="mt-2"><span className="font-semibold">Robustness checks:</span> {p.robustnessChecks.join("; ") || "—"}</div>
              <div className="mt-2"><span className="font-semibold">Fairness/side-effects:</span> {p.fairnessPanel || "—"}</div>
              <div className="mt-2"><span className="font-semibold">Identity safeguards:</span> {p.identitySafeguards.join("; ") || "—"}</div>
              <div className="mt-2"><span className="font-semibold">ATCF notes:</span> {p.atcfNotes || "—"}</div>
              <div className="mt-2"><span className="font-semibold">Failure envelope:</span> {p.failureEnvelope || "—"}</div>
              <div className="mt-2"><span className="font-semibold">Governance:</span> {p.governance || "—"}</div>
            </div>
          </div>
          <div className="mt-3 grid md:grid-cols-2 gap-3">
            <div className="p-2 bg-gray-50 rounded">
              <div className="text-xs uppercase text-gray-600">Translations</div>
              <div className="text-sm"><span className="font-semibold">Stewardship: </span>{p.translations.stewardship || "—"}</div>
              <div className="text-sm"><span className="font-semibold">Justice: </span>{p.translations.justice || "—"}</div>
              <div className="text-sm"><span className="font-semibold">Thrift: </span>{p.translations.thrift || "—"}</div>
              <div className="text-sm"><span className="font-semibold">Beauty: </span>{p.translations.beauty || "—"}</div>
            </div>
            <div className="p-2 bg-gray-50 rounded">
              <div className="text-xs uppercase text-gray-600">Score (informal)</div>
              <div className="text-2xl font-bold">{scoreProof(p)}</div>
              <div className="text-xs text-gray-600">Completeness, level, robustness, identity safety, translations</div>
            </div>
          </div>
        </div>
      );
    }

    function AuditTables({p}:{p:CapabilityProof}){
      const [evPass,setEvPass] = useState<boolean | null>(null);
      const [evNotes,setEvNotes] = useState("");
      const [idPass,setIdPass] = useState<boolean | null>(null);
      const [idNotes,setIdNotes] = useState("");
      useEffect(()=>{ if (p.adversarialFindings) setEvNotes(p.adversarialFindings); },[p.adversarialFindings]);
      return (
        <div className="grid md:grid-cols-2 gap-4 text-sm">
          <div className="border rounded p-3 bg-white">
            <div className="font-semibold mb-2">Table 1: Evidence vs Outcome Band</div>
            <div className="mb-2">Does the evidence justify the claimed band?</div>
            <div className="flex gap-2 mb-2">
              <button className={`px-3 py-1.5 rounded ${evPass===true?"bg-green-600 text-white":"bg-gray-200"}`} onClick={()=>setEvPass(true)}>Pass</button>
              <button className={`px-3 py-1.5 rounded ${evPass===false?"bg-red-600 text-white":"bg-gray-200"}`} onClick={()=>setEvPass(false)}>Fail</button>
              <button className={`px-3 py-1.5 rounded ${evPass===null?"bg-gray-900 text-white":"bg-gray-200"}`} onClick={()=>setEvPass(null)}>Unset</button>
            </div>
            <TextArea value={evNotes} onChange={setEvNotes} rows={5} placeholder="Notes: design choice, biases, replication, sensitivity…"/>
          </div>
          <div className="border rounded p-3 bg-white">
            <div className="font-semibold mb-2">Table 2: Identity / Soul-Safety (ATCF)</div>
            <div className="mb-2">Are identity safeguards adequate?</div>
            <div className="flex gap-2 mb-2">
              <button className={`px-3 py-1.5 rounded ${idPass===true?"bg-green-600 text-white":"bg-gray-200"}`} onClick={()=>setIdPass(true)}>Pass</button>
              <button className={`px-3 py-1.5 rounded ${idPass===false?"bg-red-600 text-white":"bg-gray-200"}`} onClick={()=>setIdPass(false)}>Fail</button>
              <button className={`px-3 py-1.5 rounded ${idPass===null?"bg-gray-900 text-white":"bg-gray-200"}`} onClick={()=>setIdPass(null)}>Unset</button>
            </div>
            <TextArea value={idNotes} onChange={setIdNotes} rows={5} placeholder="Notes: opt-in clarity, exit symmetry, role choice, dignity lines…"/>
          </div>
        </div>
      );
    }

    // ---------- Rubrics ----------
    const RUBRIC_CRITERIA = [
      { id: "evidence", label: "Evidence Quality (design, bias handling, replication)", weight: 25, hint: "Pragmatic design fits context; replication and sensitivities present." },
      { id: "band", label: "Outcome Band Coherence (metrics, MDE, CI)", weight: 15, hint: "Clear metrics, baseline, intervals; band justified." },
      { id: "identity", label: "Identity/Soul-Safety (ATCF)", weight: 20, hint: "Opt-in, exit symmetry, dignity protections; no coercion." },
      { id: "protocol", label: "Protocol Replicability (steps & tunables)", weight: 15, hint: "Minimal steps listed; constants vs tunables clear." },
      { id: "robustness", label: "Robustness & Failure Envelope", weight: 15, hint: "Sensitivity, ablations, failure contexts published." },
      { id: "translation", label: "Translation Fidelity (multi-grammar, truthful)", weight: 10, hint: "At least 3 faithful retellings without spin." },
    ];
    const RUBRIC_LEVELS = ["Exemplary","Proficient","Basic","Missing"] as RubricSelection[];
    const LEVEL_MULTIPLIER: Record<RubricSelection, number> = { Exemplary: 1.0, Proficient: 0.8, Basic: 0.6, Missing: 0.0 };

    function RubricPanel({p, onSave}:{p:CapabilityProof; onSave:(rubric:RubricState)=>void}){
      const [selections,setSelections] = useState<Record<string,RubricSelection>>(()=> p.rubric?.selections || Object.fromEntries(RUBRIC_CRITERIA.map((c:any)=>[c.id,"Basic"])));
      const [notes,setNotes] = useState<string>(p.rubric?.notes || "");
      function assist(){
        const s: Record<string,RubricSelection> = {...selections};
        s.evidence = (p.evidenceDesign && (p.nParticipants||0)>0) ? (p.robustnessChecks.length>=2?"Exemplary":"Proficient") : "Basic";
        s.band = (p.outcomeBand && p.baselineDesc)?"Proficient":"Basic";
        s.identity = (p.identitySafeguards.length>=2 && p.atcfNotes)?"Proficient":"Basic";
        s.protocol = (p.protocol.length>=5)?"Proficient":"Basic";
        s.robustness = (p.robustnessChecks.length>=2 && p.failureEnvelope)?"Proficient":"Basic";
        const tCount = [p.translations.stewardship,p.translations.justice,p.translations.thrift,p.translations.beauty].filter(Boolean).length;
        s.translation = tCount>=3?"Proficient":(tCount>=1?"Basic":"Missing");
        setSelections(s);
      }
      const total = RUBRIC_CRITERIA.reduce((acc:number,c:any)=> acc + c.weight * LEVEL_MULTIPLIER[selections[c.id] || "Missing"], 0);
      function save(){ onSave({ selections, notes, total }); }
      function toMarkdown(){
        const lines = [
          `# Rubric — ${p.title}`,
          `Total: ${Math.round(total)}/100`,
          "",
          ...RUBRIC_CRITERIA.map((c:any)=>`- **${c.label}** (${c.weight}): ${selections[c.id] || "Missing"}`),
          "",
          notes?`**Notes:**\n${notes}`:""
        ].filter(Boolean);
        return lines.join("\n");
      }
      async function copyMarkdown(){ try { await navigator.clipboard.writeText(toMarkdown()); } catch {} }
      return (
        <div className="border rounded-lg p-4 bg-white">
          <h3 className="text-lg font-semibold mb-2">Rubric — Weighted Criteria</h3>
          <div className="text-xs text-gray-600 mb-3">Score by criterion (Exemplary/Proficient/Basic/Missing). Weights sum to 100.</div>
          <div className="space-y-3">
            {RUBRIC_CRITERIA.map((c:any)=> (
              <div key={c.id} className="flex items-start gap-3">
                <div className="flex-1">
                  <div className="text-sm font-medium">{c.label} <span className="text-xs text-gray-500">({c.weight} pts)</span></div>
                  <div className="text-xs text-gray-500">{c.hint}</div>
                </div>
                <select className="border rounded p-1 text-sm" value={selections[c.id] || "Missing"} onChange={e=>setSelections({...selections, [c.id]: e.target.value as RubricSelection})}>
                  {RUBRIC_LEVELS.map((l:any)=> <option key={l} value={l}>{l}</option>)}
                </select>
              </div>
            ))}
          </div>
          <div className="mt-3">
            <div className="text-sm font-semibold">Notes</div>
            <TextArea value={notes} onChange={setNotes} rows={5} placeholder="Strengths, gaps, requests for changes…"/>
          </div>
          <div className="mt-3 flex items-center gap-2">
            <button className="px-3 py-1.5 rounded bg-gray-900 text-white" onClick={save}>Save to Proof</button>
            <button className="px-3 py-1.5 rounded bg-gray-200" onClick={assist}>Assist (prefill)</button>
            <div className="ml-auto text-sm">Total: <span className="font-bold">{Math.round(total)}</span>/100</div>
            <button className="px-3 py-1.5 rounded bg-amber-500 text-white" onClick={copyMarkdown}>Copy Markdown</button>
          </div>
        </div>
      );
    }

    // ---------- Proof creation form (minimal) ----------
    function ProofForm({ onSave, initial }:{ onSave:(p:CapabilityProof)=>void; initial?:CapabilityProof }){
      const [title,setTitle] = useState(initial?.title || "");
      const [functionDesc,setFunctionDesc] = useState(initial?.functionDesc || "");
      const [context,setContext] = useState(initial?.context || "");
      const [timeframe,setTimeframe] = useState(initial?.timeframe || "");
      const [baselineDesc,setBaselineDesc] = useState(initial?.baselineDesc || "");
      const [unit,setUnit] = useState(initial?.outcomeBand.unit || "% change");
      const [point,setPoint] = useState<number>(initial?.outcomeBand.point ?? -10);
      const [low,setLow] = useState<number>(initial?.outcomeBand.low ?? -5);
      const [high,setHigh] = useState<number>(initial?.outcomeBand.high ?? -15);
      const [protocol,setProtocol] = useState<string[]>(initial?.protocol || []);
      const [evidenceDesign,setEvidenceDesign] = useState(initial?.evidenceDesign || "");
      const [nParticipants,setNParticipants] = useState<number>(initial?.nParticipants ?? 0);
      const [durationWeeks,setDurationWeeks] = useState<number>(initial?.durationWeeks ?? 0);
      const [robustnessChecks,setRobustnessChecks] = useState<string[]>(initial?.robustnessChecks || []);
      const [fairnessPanel,setFairnessPanel] = useState(initial?.fairnessPanel || "");
      const [identitySafeguards,setIdentitySafeguards] = useState<string[]>(initial?.identitySafeguards || []);
      const [atcfNotes,setAtcfNotes] = useState(initial?.atcfNotes || "");
      const [governance,setGovernance] = useState(initial?.governance || "");
      const [failureEnvelope,setFailureEnvelope] = useState(initial?.failureEnvelope || "");
      const [proofLevel,setProofLevel] = useState<ProofLevel>(initial?.proofLevel ?? 1);
      const [steward,setSteward] = useState(initial?.steward || "");

      function save(){
        const p: CapabilityProof = {
          id: initial?.id || uid(),
          title, functionDesc, context, timeframe,
          outcomeBand: { point, low, high, unit },
          baselineDesc,
          protocol,
          evidenceDesign,
          nParticipants: nParticipants || undefined,
          durationWeeks: durationWeeks || undefined,
          robustnessChecks,
          fairnessPanel,
          identitySafeguards,
          atcfNotes,
          governance,
          failureEnvelope,
          proofLevel,
          steward,
          updatedAt: nowISO(),
          translations: {}
        };
        onSave(p);
      }

      return (
        <div className="border rounded-lg p-4 bg-white space-y-4">
          <h3 className="text-lg font-semibold">Create Capability Proof</h3>
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <FieldLabel title="Title"/><TextInput value={title} onChange={setTitle} placeholder="e.g., Clinic No-Show Reduction"/>
              <FieldLabel title="Function"/><TextInput value={functionDesc} onChange={setFunctionDesc} placeholder="What capability are you proving?"/>
              <FieldLabel title="Context"/><TextInput value={context} onChange={setContext} placeholder="Where/for whom?"/>
              <FieldLabel title="Timeframe"/><TextInput value={timeframe} onChange={setTimeframe} placeholder="e.g., 12 weeks"/>
              <FieldLabel title="Baseline"/><TextInput value={baselineDesc} onChange={setBaselineDesc} placeholder="What was happening before?"/>
              <FieldLabel title="Outcome Band"/>
              <div className="flex gap-2 items-center flex-wrap">
                <NumberInput value={point} onChange={setPoint}/>
                <NumberInput value={low} onChange={setLow}/>
                <NumberInput value={high} onChange={setHigh}/>
                <TextInput value={unit} onChange={setUnit} placeholder="% no-shows"/>
              </div>
              <FieldLabel title="Evidence Design"/><TextInput value={evidenceDesign} onChange={setEvidenceDesign} placeholder="e.g., stepped-wedge, matched cohort…"/>
              <div className="flex gap-3 mt-2">
                <label className="text-sm">N <NumberInput value={nParticipants} onChange={setNParticipants}/></label>
                <label className="text-sm">Weeks <NumberInput value={durationWeeks} onChange={setDurationWeeks}/></label>
              </div>
            </div>
            <div>
              <FieldLabel title="Protocol (steps)"/><ArrayEditor items={protocol} setItems={setProtocol} placeholder="Add step"/>
              <FieldLabel title="Robustness Checks"/><ArrayEditor items={robustnessChecks} setItems={setRobustnessChecks} placeholder="Add check"/>
              <FieldLabel title="Fairness / Side-Effects"/><TextArea value={fairnessPanel} onChange={setFairnessPanel} rows={3}/>
              <FieldLabel title="Identity Safeguards"/><ArrayEditor items={identitySafeguards} setItems={setIdentitySafeguards} placeholder="Add safeguard"/>
              <FieldLabel title="ATCF Notes"/><TextArea value={atcfNotes} onChange={setAtcfNotes} rows={2}/>
              <FieldLabel title="Failure Envelope"/><TextArea value={failureEnvelope} onChange={setFailureEnvelope} rows={2}/>
              <FieldLabel title="Governance"/><TextArea value={governance} onChange={setGovernance} rows={2}/>
              <div className="flex gap-3 items-center mt-2">
                <label className="text-sm">Proof Level
                  <select className="ml-2 border rounded p-1 text-sm" value={proofLevel as any} onChange={e=>setProofLevel(parseInt(e.target.value) as ProofLevel)}>
                    {[0,1,2,3,4].map(l=> <option key={l} value={l}>L{l}</option>)}
                  </select>
                </label>
                <label className="text-sm">Steward <input className="ml-2 border rounded p-1 text-sm" value={steward} onChange={e=>setSteward(e.target.value)} /></label>
              </div>
            </div>
          </div>
          <div className="flex gap-2">
            <button className="px-3 py-1.5 rounded bg-gray-900 text-white" onClick={save}>Save Proof</button>
          </div>
        </div>
      );
    }

    // ---------- Main App ----------
    type Tab = "gallery" | "create" | "audit" | "translate" | "abm" | "rubric";
    function CapabilityProofsApp(){
      const [proofs,setProofs] = useState<CapabilityProof[]>(()=>{
        const parsed = parseHash();
        if (parsed?.gallery && parsed.gallery.length) return parsed.gallery;
        const base = loadProofsLS();
        if (parsed?.proof) return [parsed.proof, ...base];
        return base;
      });
      const [active,setActive] = useState<Tab>("gallery");
      const [selectedId,setSelectedId] = useState<string | null>(proofs[0]?.id || null);
      const selected = useMemo(()=> proofs.find(p=>p.id===selectedId) || null, [proofs,selectedId]);
      useEffect(()=>{ saveProofsLS(proofs); },[proofs]);
      useEffect(()=>{ if(proofs.length && !selectedId) setSelectedId(proofs[0].id); },[proofs,selectedId]);

      function addOrUpdate(p: CapabilityProof){
        setProofs(prev=>{
          const idx = prev.findIndex(q=>q.id===p.id);
          if (idx>=0){ const next = prev.slice(); next[idx] = p; return next; }
          return [p, ...prev];
        });
        setActive("gallery");
        setSelectedId(p.id);
      }
      function remove(id:string){ setProofs(prev=>prev.filter(p=>p.id!==id)); if (selectedId===id) setSelectedId(null); }

      function exportJSON(){
        const blob = new Blob([JSON.stringify(proofs,null,2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a"); a.href = url; a.download = "amc_capability_proofs.json"; a.click(); URL.revokeObjectURL(url);
      }
      function importJSON(ev:any){ const file = ev.target.files?.[0]; if(!file) return; const reader = new FileReader(); reader.onload = ()=>{ try{ const parsed = JSON.parse(String(reader.result)); if(Array.isArray(parsed)) setProofs(parsed); } catch{} }; reader.readAsText(file); }
      function loadExamples(){ const ex = exampleProofs(); setProofs(prev=>[...ex, ...prev]); setSelectedId(ex[0].id); setActive("gallery"); }
      async function copy(text:string){ try{ await navigator.clipboard.writeText(text);}catch{} }
      const shareSelected = selected ? makeProofLink(selected) : ""; const shareGallery = makeGalleryLink(proofs);
      function saveRubric(r:RubricState){ if (!selected) return; addOrUpdate({...selected, rubric: r, updatedAt: nowISO()}); }

      return (
        <div className="p-4 md:p-6 max-w-6xl mx-auto">
          <header className="mb-4">
            <h1 className="text-2xl font-bold">AMC Capability Proofs – Teaching App (Prototype)</h1>
            <p className="text-gray-700 text-sm"><p className="text-gray-700 text-sm">Prove small. Publish bands. Protect identity. Replicate. Translate. Repair at the edges.</p>
          </header>

          <nav className="flex flex-wrap gap-2 mb-4 items-center">
            {[
              ["gallery","Gallery"],
              ["create","Create Proof"],
              ["audit","Audit"],
              ["translate","Translation Studio"],
              ["abm","ABM Sandbox"],
              ["rubric","Rubric & Share"],
            ].map(([key,label])=> (
              <button key={key} onClick={()=>setActive(key as Tab)} className={`px-3 py-1.5 rounded ${active===key?"bg-gray-900 text-white":"bg-gray-200"}`}>{label}</button>
            ))}
            <div className="flex-1"/>
            <button onClick={loadExamples} className="px-3 py-1.5 rounded bg-amber-500 text-white">Load Example Proofs</button>
            <button onClick={exportJSON} className="px-3 py-1.5 rounded bg-gray-900 text-white">Export JSON</button>
            <label className="px-3 py-1.5 rounded bg-gray-200 cursor-pointer">Import
              <input type="file" accept="application/json" onChange={importJSON} className="hidden"/>
            </label>
          </nav>

          {active==="gallery" && (
            <div className="grid md:grid-cols-2 gap-4">
              <div className="space-y-3">
                <div className="border rounded p-3 bg-white">
                  <div className="text-sm font-semibold mb-2">Proofs</div>
                  {proofs.length===0 && <div className="text-sm text-gray-600">No proofs yet. Load examples or create one.</div>}
                  <ul className="divide-y">
                    {proofs.map(p=> (
                      <li key={p.id} className={`py-2 flex items-center justify-between ${selectedId===p.id?"bg-gray-50":""}`}>
                        <button className="text-left flex-1 px-2" onClick={()=>setSelectedId(p.id)}>
                          <div className="font-medium">{p.title}</div>
                          <div className="text-xs text-gray-600">L{p.proofLevel} • Score {scoreProof(p)} • {p.outcomeBand.unit} {fmtPct(p.outcomeBand.point)}</div>
                        </button>
                        <button className="px-2 py-1 text-xs rounded bg-red-100 text-red-700" onClick={()=>remove(p.id)}>Delete</button>
                      </li>
                    ))}
                  </ul>
                </div>
                {selected && (
                  <div className="border rounded p-3 bg-white">
                    <div className="text-sm font-semibold mb-2">Adversarial Audit</div>
                    <TextArea value={selected.adversarialFindings||""} onChange={(v)=>{
                      const next = {...selected, adversarialFindings: v, updatedAt: nowISO()};
                      setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                    }} rows={6} placeholder="Try to break this claim. What could be wrong or fragile?"/>
                  </div>
                )}
              </div>
              <div>
                {selected ? <ProofCard p={selected}/> : <div className="text-sm text-gray-600">Select a proof to preview.</div>}
              </div>
            </div>
          )}

          {active==="create" && (<ProofForm onSave={addOrUpdate} initial={undefined}/>) }

          {active==="audit" && (
            selected ? (
              <div className="space-y-3">
                <ProofCard p={selected}/>
                <AuditTables p={selected}/>
              </div>
            ) : <div className="text-sm text-gray-600">Select a proof in the Gallery first.</div>
          )}

          {active==="translate" && (
            selected ? (
              <div className="grid md:grid-cols-2 gap-4">
                <div className="border rounded p-3 bg-white">
                  <div className="font-semibold mb-2">Translation Studio</div>
                  <div className="text-xs text-gray-600 mb-2">Render the <em>same verified outcome</em> in multiple moral grammars without lying.</div>
                  <div className="space-y-2">
                    <div>
                      <div className="text-xs text-gray-600">Stewardship</div>
                      <TextArea value={selected.translations.stewardship||""} onChange={(v)=>{
                        const next = {...selected, translations: {...selected.translations, stewardship: v}, updatedAt: nowISO()};
                        setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                      }}/>
                    </div>
                    <div>
                      <div className="text-xs text-gray-600">Justice</div>
                      <TextArea value={selected.translations.justice||""} onChange={(v)=>{
                        const next = {...selected, translations: {...selected.translations, justice: v}, updatedAt: nowISO()};
                        setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                      }}/>
                    </div>
                    <div>
                      <div className="text-xs text-gray-600">Thrift</div>
                      <TextArea value={selected.translations.thrift||""} onChange={(v)=>{
                        const next = {...selected, translations: {...selected.translations, thrift: v}, updatedAt: nowISO()};
                        setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                      }}/>
                    </div>
                    <div>
                      <div className="text-xs text-gray-600">Beauty</div>
                      <TextArea value={selected.translations.beauty||""} onChange={(v)=>{
                        const next = {...selected, translations: {...selected.translations, beauty: v}, updatedAt: nowISO()};
                        setProofs(prev=>prev.map(p=>p.id===selected.id?next:p));
                      }}/>
                    </div>
                  </div>
                </div>
                <div><ProofCard p={selected}/></div>
              </div>
            ) : <div className="text-sm text-gray-600">Select a proof in the Gallery first.</div>
          )}

          {active==="abm" && (<ABMSandbox/>) }

          {active==="rubric" && (
            selected ? (
              <div className="space-y-3">
                <ProofCard p={selected}/>
                <div className="grid md:grid-cols-2 gap-4">
                  <RubricPanel p={selected} onSave={saveRubric}/>
                  <div className="border rounded-lg p-4 bg-white">
                    <h3 className="text-lg font-semibold mb-2">Share Links</h3>
                    <div className="text-sm text-gray-700 mb-2">Create immutable links that carry a read-only snapshot of the selected proof or the whole gallery (encoded in the URL hash).</div>
                    <div className="space-y-3">
                      <div className="p-2 bg-gray-50 rounded">
                        <div className="text-xs uppercase text-gray-600 mb-1">Selected Proof</div>
                        <div className="text-xs break-all bg-white border rounded p-2">{selected ? makeProofLink(selected) : "Select a proof to generate a link."}</div>
                      </div>
                      <div className="p-2 bg-gray-50 rounded">
                        <div className="text-xs uppercase text-gray-600 mb-1">Gallery</div>
                        <div className="text-xs break-all bg-white border rounded p-2">{makeGalleryLink(proofs)}</div>
                      </div>
                      <div className="text-xs text-gray-600">Tip: Links use the URL hash (after #), so they can be shared safely without a server; recipients can import via the link or your exported JSON.</div>
                    </div>
                  </div>
                </div>
              </div>
            ) : <div className="text-sm text-gray-600">Select a proof in the Gallery first.</div>
          )}

          <footer className="mt-8 text-xs text-gray-500">
            <div>Prototype: AMC Capability Proofs • Keep the center simple. Let complexity live at the edges. Instrument edges. Repair quickly.</div>
          </footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<CapabilityProofsApp/>);
  </script>
</body>
</html>
